"""
FINAM mHM module.
"""
# pylint: disable=R1735
from datetime import datetime, timedelta

import finam as fm
import mhm
import numpy as np

OUTPUT_META = {
    "L0_GRIDDED_LAI": dict(units="1", long_name="leaf area index"),
    "L1_FSEALED": dict(units="1", long_name="Fraction of sealed area"),
    "L1_FNOTSEALED": dict(units="1", long_name="Fraction of unsealed area"),
    "L1_INTER": dict(units="mm / h", long_name="Interception"),  # interception (1)
    "L1_SNOWPACK": dict(units="mm / h", long_name="Snowpack"),  # snowpack (2)
    "L1_SEALSTW": dict(
        units="mm / h", long_name="Retention storage of impervious areas"
    ),  # sealedSTW (6)
    "L1_UNSATSTW": dict(units="mm / h", long_name="upper soil storage"),  # unsatSTW (7)
    "L1_SATSTW": dict(units="mm / h", long_name="groundwater storage"),  # satSTW (8)
    "L1_NEUTRONS": dict(
        units="mm / h", long_name="Ground Albedo Neutrons"
    ),  # neutrons (18)
    "L1_PET_CALC": dict(
        units="mm / h", long_name="potential evapotranspiration"
    ),  # PET (9)
    "L1_AETCANOPY": dict(
        units="mm / h", long_name="Real evaporation intensity from canopy"
    ),
    "L1_AETSEALED": dict(
        units="mm / h", long_name="Real evap. from free water surfaces"
    ),
    "L1_TOTAL_RUNOFF": dict(units="mm / h", long_name="Generated runoff"),  # Q (11)
    "L1_RUNOFFSEAL": dict(
        units="mm / h", long_name="Direct runoff from impervious areas"
    ),
    "L1_FASTRUNOFF": dict(units="mm / h", long_name="Fast runoff component"),
    "L1_SLOWRUNOFF": dict(units="mm / h", long_name="Slow runoff component"),
    "L1_BASEFLOW": dict(units="mm / h", long_name="Baseflow"),
    "L1_PERCOL": dict(units="mm / h", long_name="Percolation"),
    "L1_PREEFFECT": dict(
        units="mm / h", long_name="Effective precip. depth"
    ),  # preEffect (20)
    "L1_SOILMOIST_VOL_ALL": dict(
        units="1", long_name="average soil moisture over all layers"
    ),  # SM_Lall (5)
    "L11_QMOD": dict(units="m^3 / s", long_name="Simulated discharge"),
    "L11_QOUT": dict(units="m^3 / s", long_name="Total outflow from cells"),
}
"""dict: meta information about available outputs in mHM."""

OUTPUT_HORIZONS_META = {
    "L1_SOILMOIST": dict(
        units="mm", long_name="soil water content of soil layer {n}"
    ),  # SWC_Lxx (3)
    "L1_SOILMOIST_VOL": dict(
        units="mm / mm", long_name="volumetric soil moisture of soil layer {n}"
    ),  # SM_Lxx (4)
    "L1_SOILMOISTSAT": dict(
        units="mm", long_name="saturation soil moisture of soil layer {n}"
    ),
    "L1_AETSOIL": dict(units="mm / h", long_name="actual ET  of soil layer {n}"),
    "L1_INFILSOIL": dict(
        units="mm / h", long_name="infiltration intensity of soil layer {n}"
    ),
    # missing
    # L1_MELT
    # L1_RAIN
    # L1_SNOW
    # L1_THROUGHFALL
}
"""dict: meta information about available outputs per horizon in mHM."""

OUTPUT_CALC_META = {
    # sum(aETSoil(horizons)) * fNotSealed + aETCanopy + aETSealed * fSealed
    "L1_AET": dict(units="mm / h", long_name="actual Evapotranspiration"),  # aET (10)
    # runoffSeal * fSealed
    "L1_QD": dict(
        units="mm / h", long_name="direct runoff generated by every cell (runoffSeal)"
    ),  # QD (12)
    # fastRunoff * fNotSealed
    "L1_QIF": dict(
        units="mm / h", long_name="fast interflow generated by every cell (fastRunoff)"
    ),  # QIf (13)
    # slowRunoff * fNotSealed
    "L1_QIS": dict(
        units="mm / h", long_name="slow interflow generated by every cell (slowRunoff)"
    ),  # QIs (14)
    # baseflow * fNotSealed
    "L1_QB": dict(
        units="mm / h", long_name="baseflow generated by every cell"
    ),  # QB (15)
    # percol * fNotSealed
    "L1_RECHARGE": dict(
        units="mm / h", long_name="groundwater recharge"
    ),  # recharge (16)
}
"""dict: meta information about calculated outputs in mHM."""

OUTPUT_CALC_HORIZONS_META = {
    # infilSoil(horizon) * fNotSealed
    "L1_SOIL_INFIL": dict(
        units="mm / h", long_name="infiltration flux from soil layer {n}"
    ),  # soil_infil_Lxx (17)
    # aETSoil(horizon) * fNotSealed
    "L1_AET": dict(
        units="mm / h", long_name="actual Evapotranspiration from soil layer {n}"
    ),  # aET_Lxx (19)
}
"""dict: meta information about calculated outputs per horizon in mHM."""

INPUT_UNITS = {
    "L0_GRIDDED_LAI": "1",
    "METEO_PRE": "mm / {ts}",
    "METEO_TEMP": "degC",
    "METEO_PET": "mm / {ts}",
    "METEO_TMIN": "degC",
    "METEO_TMAX": "degC",
    "METEO_NETRAD": "W m-2",
    "METEO_ABSVAPPRESS": "Pa",
    "METEO_WINDSPEED": "m s-1",
    "METEO_SSRD": "W m-2",
    "METEO_STRD": "W m-2",
    "METEO_TANN": "degC",
}
"""dict: units of the available inputs in mHM."""

HOURS_TO_TIMESTEP = {1: "h", 24: "d"}
"""dict: timestep string from hours."""


def _fill_var(var, grid="l1"):
    grid_info = getattr(mhm.get, grid + "_domain_info")()
    # mask in mHM is the opposite in numpy (selection)
    sel = mhm.get_mask(grid, indexing="xy", selection=True)
    sel = sel.ravel(order="F")
    output = np.ma.empty_like(sel, dtype=float)
    output.fill_value = grid_info[-1]
    output.mask = ~sel
    output[sel] = var
    return output.reshape((grid_info[0], grid_info[1]), order="C")


def _L1_AET():
    # sum(aETSoil(horizons)) * fNotSealed + aETCanopy + aETSealed * fSealed
    fsealed = mhm.get_variable("L1_FSEALED", compressed=True)
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    aetcanopy = mhm.get_variable("L1_AETCANOPY", compressed=True)
    aetsealed = mhm.get_variable("L1_AETSEALED", compressed=True)
    horizons = mhm.get.number_of_horizons()

    sum_aetsoil = np.zeros_like(fsealed, dtype=float)
    for n in range(1, horizons + 1):
        sum_aetsoil += mhm.get_variable("L1_AETSOIL", index=n, compressed=True)

    return _fill_var(sum_aetsoil * fnotsealed + aetcanopy + aetsealed * fsealed)


def _L1_QD():
    # runoffSeal * fSealed
    fsealed = mhm.get_variable("L1_FSEALED", compressed=True)
    runoffseal = mhm.get_variable("L1_RUNOFFSEAL", compressed=True)
    return _fill_var(runoffseal * fsealed)


def _L1_QIF():
    # fastRunoff * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    fastrunoff = mhm.get_variable("L1_FASTRUNOFF", compressed=True)
    return _fill_var(fastrunoff * fnotsealed)


def _L1_QIS():
    # slowRunoff * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    slowrunoff = mhm.get_variable("L1_SLOWRUNOFF", compressed=True)
    return _fill_var(slowrunoff * fnotsealed)


def _L1_QB():
    # baseflow * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    baseflow = mhm.get_variable("L1_BASEFLOW", compressed=True)
    return _fill_var(baseflow * fnotsealed)


def _L1_RECHARGE():
    # percol * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    percol = mhm.get_variable("L1_PERCOL", compressed=True)
    return _fill_var(percol * fnotsealed)


def _L1_SOIL_INFIL_N(n):
    # infilSoil(horizon) * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    infilsoil = mhm.get_variable("L1_INFILSOIL", index=n, compressed=True)
    return _fill_var(infilsoil * fnotsealed)


def _L1_AET_N(n):
    # aETSoil(horizon) * fNotSealed
    fnotsealed = mhm.get_variable("L1_FNOTSEALED", compressed=True)
    aetsoil = mhm.get_variable("L1_AETSOIL", index=n, compressed=True)
    return _fill_var(aetsoil * fnotsealed)


OUTPUT_CALC = {
    "L1_AET": _L1_AET,
    "L1_QD": _L1_QD,
    "L1_QIF": _L1_QIF,
    "L1_QIS": _L1_QIS,
    "L1_QB": _L1_QB,
    "L1_RECHARGE": _L1_RECHARGE,
}

OUTPUT_CALC_HORIZON = {
    "L1_SOIL_INFIL": _L1_SOIL_INFIL_N,
    "L1_AET": _L1_AET_N,
}


def _horizon_name(name, horizon):
    return name + "_L" + str(horizon).zfill(2)


def _get_grid_name(var):
    grid_name = var.split("_")[0]
    return "L1" if grid_name == "METEO" else grid_name


def _get_var_name(var):
    return "_".join(var.split("_")[1:])


def _get_meteo_inputs(inputs):
    return {
        _get_var_name(var).lower(): var for var in inputs if var.startswith("METEO")
    }


class MHM(fm.TimeComponent):
    """
    mHM FINAM compoment.

    Parameters
    ----------
    namelist_mhm : str, optional
        path to mHM configuration namelist, by default "mhm.nml"
    namelist_mhm_param : str, optional
        path to mHM parameter namelist, by default "mhm_parameter.nml"
    namelist_mhm_output : str, optional
        path to mHM output namelist, by default "mhm_outputs.nml"
    namelist_mrm_output : str, optional
        path to mRM output namelist, by default "mrm_outputs.nml"
    cwd : str, optional
        desired working directory, by default "."
    input_names : list of str, optional
        Names of input variables coupled via FINAM, by default None
    meteo_timestep : int, optional
        meteo coupling time-step in hours (1 or 24), by default None
    ignore_input_grid : bool, optional
        use any input grid without checking compatibility, by default False

    Raises
    ------
    ValueError
        If a given input name is invalid.
    ValueError
        If the given meteo time-step is invalid
    """

    def __init__(
        self,
        namelist_mhm="mhm.nml",
        namelist_mhm_param="mhm_parameter.nml",
        namelist_mhm_output="mhm_outputs.nml",
        namelist_mrm_output="mrm_outputs.nml",
        cwd=".",
        input_names=None,
        meteo_timestep=None,
        ignore_input_grid=False,
    ):
        super().__init__()
        self.gridspec = {}
        self.no_data = None
        self.number_of_horizons = None

        self.OUTPUT_NAMES = None
        self.INPUT_NAMES = (
            [] if input_names is None else [n.upper() for n in input_names]
        )
        for in_name in self.INPUT_NAMES:
            if in_name not in INPUT_UNITS:
                msg = f"mHM: input '{in_name}' is not available."
                raise ValueError(msg)
        self.namelist_mhm = namelist_mhm
        self.namelist_mhm_param = namelist_mhm_param
        self.namelist_mhm_output = namelist_mhm_output
        self.namelist_mrm_output = namelist_mrm_output
        self.cwd = cwd  # needed for @fm.tools.execute_in_cwd
        # mHM always has hourly stepping
        self.step = timedelta(hours=1)
        self.meteo_timestep = meteo_timestep
        self.meteo_inputs = _get_meteo_inputs(self.INPUT_NAMES)
        self.ignore_input_grid = ignore_input_grid

        if self.meteo_inputs and self.meteo_timestep not in HOURS_TO_TIMESTEP:
            msg = (
                "mHM: found meteo inputs but meteo time-step not valid, "
                f"got {self.meteo_timestep}"
            )
            raise ValueError(msg)

    @property
    def next_time(self):
        """Next pull time."""
        return self.time + self.step

    @property
    def horizons(self):
        """Iterator for all horizons starting at 1."""
        return range(1, self.number_of_horizons + 1)

    @fm.tools.execute_in_cwd
    def _initialize(self):
        # only show errors
        mhm.model.set_verbosity(level=1)
        # configure coupling
        if self.meteo_inputs:
            kwargs = {f"meteo_expect_{var}": True for var in self.meteo_inputs}
            kwargs["couple_case"] = 1
            kwargs["meteo_timestep"] = self.meteo_timestep
            mhm.model.config_coupling(**kwargs)
        # init
        mhm.model.init(
            namelist_mhm=self.namelist_mhm,
            namelist_mhm_param=self.namelist_mhm_param,
            namelist_mhm_output=self.namelist_mhm_output,
            namelist_mrm_output=self.namelist_mrm_output,
            cwd=".",
        )
        # disable file output of mHM
        mhm.model.disable_output()
        mhm.run.prepare()
        # only one domain possible
        mhm.run.prepare_domain()
        self.number_of_horizons = mhm.get.number_of_horizons()
        # prepare outputs
        self.OUTPUT_NAMES = list(OUTPUT_META)
        self.OUTPUT_NAMES += [
            _horizon_name(var, horizon)
            for var in OUTPUT_HORIZONS_META
            for horizon in self.horizons
        ]
        self.OUTPUT_NAMES += list(OUTPUT_CALC_META)
        self.OUTPUT_NAMES += [
            _horizon_name(var, horizon)
            for var in OUTPUT_CALC_HORIZONS_META
            for horizon in self.horizons
        ]
        # get start time
        year, month, day, hour = mhm.run.current_time()
        self.time = datetime(year=year, month=month, day=max(day, 0), hour=max(hour, 0))
        # first time step compensate by negative values in mHM
        if day < 0 or hour < 0:
            self.time += timedelta(days=min(day, 0), hours=min(hour, 0))

        # store Grid specifications
        # get grid info l0 (swap rows/cols to get "ij" indexing)
        nrows, ncols, __, xll, yll, cell_size, no_data = mhm.get.l0_domain_info()
        self.no_data = no_data
        self.gridspec["L0"] = fm.EsriGrid(
            ncols=ncols, nrows=nrows, cellsize=cell_size, xllcorner=xll, yllcorner=yll
        )
        # get grid info l1 (swap rows/cols to get "ij" indexing)
        nrows, ncols, __, xll, yll, cell_size, no_data = mhm.get.l1_domain_info()
        self.gridspec["L1"] = fm.EsriGrid(
            ncols=ncols, nrows=nrows, cellsize=cell_size, xllcorner=xll, yllcorner=yll
        )
        # get grid info l11 (swap rows/cols to get "ij" indexing)
        nrows, ncols, __, xll, yll, cell_size, no_data = mhm.get.l11_domain_info()
        self.gridspec["L11"] = fm.EsriGrid(
            ncols=ncols, nrows=nrows, cellsize=cell_size, xllcorner=xll, yllcorner=yll
        )
        # get grid info l2 (swap rows/cols to get "ij" indexing)
        nrows, ncols, __, xll, yll, cell_size, no_data = mhm.get.l2_domain_info()
        self.gridspec["L2"] = fm.EsriGrid(
            ncols=ncols, nrows=nrows, cellsize=cell_size, xllcorner=xll, yllcorner=yll
        )
        for var, meta in OUTPUT_META.items():
            grid_name = _get_grid_name(var)
            self.outputs.add(
                name=var,
                time=self.time,
                grid=self.gridspec[grid_name],
                missing_value=self.no_data,
                _FillValue=self.no_data,
                **meta,
            )
        for var, meta in OUTPUT_CALC_META.items():
            grid_name = _get_grid_name(var)
            self.outputs.add(
                name=var,
                time=self.time,
                grid=self.gridspec[grid_name],
                missing_value=self.no_data,
                _FillValue=self.no_data,
                **meta,
            )
        for var, meta in OUTPUT_HORIZONS_META.items():
            grid_name = _get_grid_name(var)
            for horizon in self.horizons:
                # add horizon number to long name
                n_meta = {
                    att: val.format(n=horizon) if att == "long_name" else val
                    for att, val in meta.items()
                }
                self.outputs.add(
                    name=_horizon_name(var, horizon),
                    time=self.time,
                    grid=self.gridspec[grid_name],
                    missing_value=self.no_data,
                    _FillValue=self.no_data,
                    **n_meta,
                )
        for var, meta in OUTPUT_CALC_HORIZONS_META.items():
            grid_name = _get_grid_name(var)
            for horizon in self.horizons:
                # add horizon number to long name
                n_meta = {
                    att: val.format(n=horizon) if att == "long_name" else val
                    for att, val in meta.items()
                }
                self.outputs.add(
                    name=_horizon_name(var, horizon),
                    time=self.time,
                    grid=self.gridspec[grid_name],
                    missing_value=self.no_data,
                    _FillValue=self.no_data,
                    **n_meta,
                )
        for var in self.INPUT_NAMES:
            grid_name = _get_grid_name(var)
            self.inputs.add(
                name=var,
                time=self.time,
                grid=None if self.ignore_input_grid else self.gridspec[grid_name],
                missing_value=self.no_data,
                _FillValue=self.no_data,
                units=INPUT_UNITS[var].format(
                    ts=HOURS_TO_TIMESTEP[self.meteo_timestep]
                ),
            )
        self.create_connector()

    def _connect(self, start_time):
        push_data = {var: mhm.get_variable(var) for var in OUTPUT_META}
        push_data.update({var: func() for var, func in OUTPUT_CALC.items()})
        push_data.update(
            {
                _horizon_name(var, horizon): mhm.get_variable(var, index=horizon)
                for var in OUTPUT_HORIZONS_META
                for horizon in self.horizons
            }
        )
        push_data.update(
            {
                _horizon_name(var, horizon): func(horizon)
                for var, func in OUTPUT_CALC_HORIZON.items()
                for horizon in self.horizons
            }
        )
        self.try_connect(start_time=start_time, push_data=push_data)

    @fm.tools.execute_in_cwd
    def _update(self):
        # Don't run further than mHM can
        if mhm.run.finished():
            return
        # set meteo data
        if self.meteo_inputs:
            # every hour or every 24 hours
            if self.time.hour % self.meteo_timestep == 0:
                kwargs = {
                    var: self.inputs[name].pull_data(self.next_time)[0].magnitude
                    for var, name in self.meteo_inputs.items()
                }
                kwargs["time"] = self.time
                mhm.set_meteo(**kwargs)
        # run mhm
        mhm.run.do_time_step()
        # update time
        year, month, day, hour = mhm.run.current_time()
        self.time = datetime(year=year, month=month, day=day, hour=hour)
        # push outputs
        for var in OUTPUT_META:
            if not self.outputs[var].has_targets:
                continue
            self.outputs[var].push_data(
                data=mhm.get_variable(var),
                time=self.time,
            )
        for var, func in OUTPUT_CALC.items():
            if not self.outputs[var].has_targets:
                continue
            self.outputs[var].push_data(
                data=func(),
                time=self.time,
            )
        for var in OUTPUT_HORIZONS_META:
            for horizon in self.horizons:
                name = _horizon_name(var, horizon)
                if not self.outputs[name].has_targets:
                    continue
                self.outputs[name].push_data(
                    data=mhm.get_variable(var, index=horizon),
                    time=self.time,
                )
        for var, func in OUTPUT_CALC_HORIZON.items():
            for horizon in self.horizons:
                name = _horizon_name(var, horizon)
                if not self.outputs[name].has_targets:
                    continue
                self.outputs[name].push_data(
                    data=func(horizon),
                    time=self.time,
                )

    @fm.tools.execute_in_cwd
    def _finalize(self):
        mhm.run.finalize_domain()
        mhm.run.finalize()
        mhm.model.finalize()
